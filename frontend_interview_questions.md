# Топ-30 вопросов на собеседовании Frontend разработчика (от Junior до Middle)

Этот список сбалансирован и включает как базовые вопросы для разогрева, так и более глубокие темы, которые спрашивают практически везде.

## JavaScript Core

### База (Must Know)

1.  **Типы данных и сравнение**: Какие есть типы данных в JS? В чем разница между `null` и `undefined`? В чем отличие `==` от `===`?

    - **Типы**: В JS 8 типов данных: 7 примитивов (`string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`) и 1 ссылочный (`object`).
    - **null vs undefined**: `undefined` означает, что переменная объявлена, но значение не присвоено. `null` — это специальное значение, которое явно указывает на "пустоту" или отсутствие объекта.
    - **== vs ===**: `==` (нестрогое равенство) приводит типы перед сравнением (например, `'5' == 5` вернет `true`), а `===` (строгое равенство) сравнивает и значение, и тип (вернет `false`). Всегда лучше использовать `===`.

2.  **Переменные**: Разница между `var`, `let` и `const`. Что такое всплытие (hoisting)?

    - **var**: Функциональная область видимости, подвержен всплытию (hoisting) с инициализацией `undefined`, можно переобъявлять. Устаревший способ.
    - **let**: Блочная область видимости, всплывает, но попадает в "мертвую зону" (TDZ) до объявления, нельзя переобъявлять в том же блоке.
    - **const**: Как `let`, но требует обязательной инициализации и запрещает переприсваивание (хотя свойства объекта внутри `const` менять можно).
    - **Hoisting**: Механизм, когда объявления переменных и функций "поднимаются" вверх своей области видимости перед выполнением кода.

3.  **Методы массивов**: Для чего нужны `map`, `filter`, `reduce`, `forEach`? Чем `map` отличается от `forEach`? Как работают `push`, `pop`, `shift`, `unshift`?

    - **map**: Создает новый массив, преобразуя каждый элемент.
    - **filter**: Создает новый массив, оставляя только те элементы, которые прошли проверку.
    - **reduce**: Сворачивает массив в одно значение (аккумулятор).
    - **forEach**: Просто перебирает массив, ничего не возвращает (используется для сайд-эффектов).
    - **push/pop**: Добавляют/удаляют элемент в _конце_ массива (быстро).
    - **shift/unshift**: Удаляют/добавляют элемент в _начале_ массива (медленнее, так как сдвигают индексы).

4.  **Функции**: Разница между Function Declaration и Function Expression. Чем стрелочная функция отличается от обычной?

    - **Function Declaration**: `function name() {}`. Всплывает полностью (можно вызвать до объявления).
    - **Function Expression**: `const name = function() {}`. Не всплывает (создается, когда доходит код).
    - **Стрелочные функции**: `() => {}`. Не имеют своего `this` (берут из внешнего контекста), нет `arguments`, нельзя использовать как конструктор.

### Продвинутые (Core)

5.  **Event Loop**: Как работает цикл событий? Микрозадачи и макрозадачи.

    - JS однопоточный. **Event Loop** следит за стеком вызовов (Call Stack) и очередью задач. Если стек пуст, он берет задачи из очереди.
    - **Микрозадачи** (Promises, `queueMicrotask`): имеют высокий приоритет, выполняются сразу после текущего кода, перед перерисовкой.
    - **Макрозадачи** (`setTimeout`, `setInterval`, события DOM): выполняются после того, как очередь микрозадач пуста.

6.  **Замыкания (Closures)**: Что такое замыкание? Пример: счетчик или приватные переменные.

    - Это способность функции запоминать свою лексическую область видимости (переменные вокруг), даже когда она выполняется вне этой области.
    - **Пример**: Функция, возвращающая другую функцию, которая использует переменную из родительской. Это позволяет создавать приватные переменные (инкапсуляция).

7.  **Контекст `this`**: Как работает `this`? Методы `call`, `apply`, `bind`.

    - `this` ссылается на объект, который вызывает функцию (контекст вызова).
    - **call/apply**: Вызывают функцию с явно заданным `this`. `call` принимает аргументы через запятую, `apply` — массивом.
    - **bind**: Возвращает _новую_ функцию с жестко привязанным контекстом `this`, не вызывает её сразу.

8.  **Прототипы**: Что такое прототипное наследование?

    - В JS объекты могут наследовать свойства и методы от других объектов через ссылку `[[Prototype]]` (доступна как `__proto__`).
    - Если свойство не найдено в самом объекте, поиск идет вверх по цепочке прототипов до `null`.

9.  **Асинхронность**: Callbacks vs Promises vs Async/Await. Обработка ошибок.

    - **Callbacks**: Старый подход, сложен в поддержке ("callback hell").
    - **Promises**: Объект, представляющий результат будущей операции. Позволяет строить цепочки `.then()`.
    - **Async/Await**: Синтаксический сахар над промисами, делает код линейным и читаемым.
    - **Ошибки**: В async/await обрабатываются через `try/catch`.

10. **Копирование**: Shallow vs Deep copy. `JSON.parse(JSON.stringify())` vs `structuredClone`.

    - **Shallow copy** (Поверхностное): Копирует только первый уровень (`...spread`, `Object.assign`). Вложенные объекты остаются ссылками.
    - **Deep copy** (Глубокое): Полная копия всех уровней.
    - `JSON.parse(JSON.stringify())`: Простой способ, но не работает с функциями, `undefined`, датами.
    - `structuredClone()`: Современный стандартный метод для глубокого копирования.

## DOM & Browser API

### База

11. **Манипуляции с DOM**: Как найти элемент (`querySelector`, `getElementById`)? Как добавить/удалить класс? Как изменить текст элемента?

    - **Поиск**: `document.querySelector('.class')` (универсальный, находит первый), `document.getElementById('id')` (быстрый, по ID).
    - **Классы**: `element.classList.add('class')`, `element.classList.remove('class')`, `element.classList.toggle('class')`.
    - **Текст**: `element.textContent = 'Текст'` (безопасно, только текст), `element.innerHTML = '<span>HTML</span>'` (парсит HTML, осторожно с XSS).

12. **События**: Как повесить обработчик события (`addEventListener`)? Что такое `event.target` и `event.currentTarget`?

    - **Обработчик**: `element.addEventListener('click', handler)`. Позволяет вешать несколько обработчиков.
    - **target**: Элемент, на котором _реально_ произошло событие (например, кликнули по иконке внутри кнопки).
    - **currentTarget**: Элемент, на котором _висит_ обработчик (сама кнопка).

### Продвинутые

13. **Всплытие и погружение**: Event Bubbling & Capturing. `stopPropagation()`.

    - **Погружение (Capturing)**: Событие идет от `window` вниз к целевому элементу.
    - **Всплытие (Bubbling)**: Событие идет от целевого элемента вверх к `window`. Большинство событий всплывают.
    - **stopPropagation()**: Останавливает дальнейшее всплытие события, чтобы оно не сработало на родительских элементах.

14. **Делегирование событий**: Зачем вешать один обработчик на родителя вместо множества на детей?

    - Это прием, когда вешают один обработчик на общего родителя, а не на каждый дочерний элемент.
    - Использует всплытие: в обработчике проверяют `event.target`, чтобы понять, какой потомок был кликнут.
    - **Плюсы**: Экономит память (меньше функций), работает для динамически добавляемых элементов.

15. **Storage**: `localStorage` vs `sessionStorage` vs `cookies`.

    - **localStorage**: Хранит данные бессрочно (пока не очистят), доступен на всех вкладках домена. (~5-10MB).
    - **sessionStorage**: Хранит данные только пока открыта вкладка браузера.
    - **Cookies**: Маленький объем (4KB), отправляются на сервер с каждым запросом. Используются для авторизации (токены) и настроек.

## CSS & Layout

### База

16. **Блочная модель (Box Model)**: `margin`, `border`, `padding`, `content`. `box-sizing: border-box`.

    - Элемент состоит из: `content` (контент) -> `padding` (внутренний отступ) -> `border` (рамка) -> `margin` (внешний отступ).
    - **box-sizing: border-box**: Изменяет расчет ширины/высоты. `width` теперь включает в себя `content` + `padding` + `border`, а не только контент. Это упрощает верстку.

17. **Позиционирование**: Как работают значения `position`: `static`, `relative`, `absolute`, `fixed`, `sticky`?

    - **static**: По умолчанию. Элемент в общем потоке.
    - **relative**: В потоке, но можно сдвигать (`top`, `left`) относительно исходного места. Является "опорным" для `absolute` потомков.
    - **absolute**: Вырван из потока. Позиционируется относительно ближайшего `relative` (или `absolute`/`fixed`) родителя.
    - **fixed**: Вырван из потока. Фиксируется относительно окна браузера (не скроллится).
    - **sticky**: "Липкое". Ведет себя как `relative`, но при прокрутке "прилипает" к краю экрана.

18. **Центрирование**: Как отцентровать `div` внутри другого `div` (по центру экрана)?

    - **Flexbox**: Родителю `display: flex; justify-content: center; align-items: center;`. Самый современный способ.
    - **Grid**: Родителю `display: grid; place-items: center;`.
    - **Absolute**: Элементу `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);`.

19. **Скрытие элементов**: Разница между `display: none`, `visibility: hidden` и `opacity: 0`.

    - **display: none**: Элемент полностью удаляется из потока (не занимает место), дети тоже скрыты. Перерисовка страницы (Reflow).
    - **visibility: hidden**: Элемент невидим, но _занимает место_ в макете. События не работают.
    - **opacity: 0**: Элемент прозрачен, занимает место, события _работают_ (можно кликнуть).

### Продвинутые

20. **Flexbox vs Grid**: Основные концепции. Оси во флексбоксе.

    - **Flexbox**: Одномерная сетка (строка _или_ колонка). Идеален для выравнивания элементов в ряд, меню, центрирования.
    - **Grid**: Двумерная сетка (строки _и_ колонки одновременно). Мощнее, подходит для создания каркаса всей страницы.
    - **Оси Flex**: Главная ось (`main axis`) — по ней выравнивает `justify-content`. Поперечная ось (`cross axis`) — по ней `align-items`. Направление меняется через `flex-direction`.

21. **Специфичность (Вес селекторов)**: Почему стиль может не применяться? Как перебить стили?

    - Браузер вычисляет "вес" селектора, чтобы понять, какое правило применить.
    - **Иерархия**: Инлайн-стили > ID > Классы > Теги.
    - Если стиль не применяется, скорее всего, его перебивает более специфичный селектор.
    - **Как перебить**: Увеличить специфичность (добавить класс или ID), либо использовать `!important` (крайняя мера, лучше избегать).

22. **Адаптив**: Media queries. Единицы `rem`, `em`, `vh`, `vw`.

    - **Media queries**: `@media` позволяют менять стили в зависимости от ширины экрана (например, для мобильных).
    - **rem**: Размер относительно корневого шрифта (`html`). Удобно для глобального масштабирования.
    - **em**: Размер относительно шрифта текущего элемента.
    - **vh/vw**: 1% от высоты (`vh`) или ширины (`vw`) окна браузера.

## HTML & Semantics

23. **Базовые теги**: Разница между `<div>` и `<span>` (block vs inline). Для чего нужен атрибут `alt` у картинок?

    - **div**: Блочный элемент. Занимает всю ширину, переносит строку. Для структуры.
    - **span**: Строчный элемент. Занимает только место контента, не переносит строку. Для текста.
    - **alt**: Описание картинки. Нужно, если картинка не загрузилась, и для скринридеров (доступность), а также для SEO.

24. **Семантика**: Зачем использовать `<header>`, `<main>`, `<footer>` вместо `div`? (SEO, доступность).

    - **Смысл**: Эти теги говорят браузеру и поисковикам, _что_ находится внутри (шапка, основной контент, подвал).
    - **Зачем**: Улучшает SEO (роботы лучше понимают структуру) и доступность (люди с ограниченными возможностями могут быстрее навигироваться).

## Network & General

25. **HTTP запросы**: GET vs POST. Что такое статус 200, 404, 500?

    - **GET**: Получение данных. Параметры видны в URL. Кэшируется.
    - **POST**: Отправка данных (создание ресурса). Данные в теле запроса. Безопаснее для паролей.
    - **Статусы**: `200` (ОК), `404` (Не найдено), `500` (Ошибка сервера).

26. **CORS**: Почему браузер блокирует запросы к другому домену?

    - **CORS** (Cross-Origin Resource Sharing) — механизм безопасности. Браузеры запрещают сайту A делать запросы к сайту B, если сайт B явно это не разрешил (через заголовки). Это защищает от кражи данных.

27. **Git**: Основные команды (`add`, `commit`, `push`, `pull`, `merge`). Что такое ветки?

    - **Команды**: `add` (подготовить файлы), `commit` (сохранить изменения), `push` (отправить в репозиторий), `pull` (скачать изменения), `merge` (объединить ветки).
    - **Ветки**: Копии кода для разработки новых фич изолированно от основной версии (`main`).

## Бонус: Задачи на код (Live Coding)

28. **Палиндром**: Написать функцию проверки строки на палиндром.

    ```javascript
    function isPalindrome(str) {
      const clean = str.toLowerCase().replace(/[^a-z0-9]/g, "");
      return clean === clean.split("").reverse().join("");
    }
    ```

29. **FizzBuzz**: Вывести числа от 1 до 100, заменяя кратные 3 на Fizz, 5 на Buzz.

    ```javascript
    for (let i = 1; i <= 100; i++) {
      let out = "";
      if (i % 3 === 0) out += "Fizz";
      if (i % 5 === 0) out += "Buzz";
      console.log(out || i);
    }
    ```

30. **Уникальные значения**: Убрать дубликаты из массива.

    ```javascript
    // Самый простой способ (ES6)
    const unique = (arr) => [...new Set(arr)];
    ```
