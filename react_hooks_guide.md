# Основные React Hooks

## 1. useState

Используется, когда компоненту нужно хранить какое-то своё состояние — текст инпута, флаг загрузки, счетчик, выбранный элемент и т.д.

При обновлении состояния компонент перерисовывается, и новое значение становится доступно в рендере.

**Когда применять:**
- простые значения (строка, число, объект, массив)
- состояние, которое зависит от действий пользователя

---

## 2. useEffect

Запускает код, который не относится напрямую к рендеру.

**Типичные задачи:**
- загрузить данные с API
- слушать события (scroll, resize)
- ставить и убирать таймеры
- синхронизировать state с localStorage или внешними системами

**Поведение зависит от зависимостей:**
- пустой массив `[]` → запустится 1 раз (при монтировании)
- массив с зависимостями `[deps]` → только когда они меняются
- без массива → при каждом рендере

---

## 3. useContext

Даёт доступ к значениям, которые хранятся в Context, без передачи их через props на каждом уровне.

**Обычно используют для:**
- темы (dark/light)
- авторизованного пользователя
- глобальных настроек
- общих данных, которым нужен доступ из многих компонентов

Сокращает проп-дриллинг.

---

## 4. useRef

Хранит изменяемое значение, которое не вызывает ререндеры при изменении.

**Основные применения:**
- доступ к DOM (например, получить `input.focus()`)
- хранение «mutable» переменных между рендерами (таймеры, прошлые значения, флаги)
- предотвращение лишних эффектов (например, "делать что-то только один раз")

---

## 5. useMemo

Оптимизация. Сохраняет результат вычисления, если зависимости не изменились.

**Нужно, если вычисление тяжёлое или слишком часто перезапускается.**

**Примеры:**
- фильтрация большого списка
- сложные вычисления
- форматирование данных, которое дорого обходится

Без него может лагать интерфейс.

---

## 6. useCallback

Очень похож на useMemo, но кэширует функцию, а не значение.

**Зачем это нужно:**
- чтобы передавать стабильные функции вниз по дереву
- чтобы мемоизированные дочерние компоненты не ререндерились зря

Вторая частая задача — зависимость внутри useEffect (чтобы не вызывать эффект бесконечно).

---

## 7. useReducer

Локальный аналог Redux.

**Подходит, когда:**
- состояние сложное
- нужно много разных действий
- логика обновления запутанная
- несколько частей состояния меняются взаимосвязанно

Управление состоянием описано функцией "reducer", где чётко прописано: какое действие → какие изменения.
